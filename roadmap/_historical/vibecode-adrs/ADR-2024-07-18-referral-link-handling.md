> Imported from vibecode/decisions/adr/ADR-2024-07-18-referral-link-handling.md on 2025-08-21

# ADR-2024-07-18: Referral Link Handling and Transaction Routing

## Context
The platform needs to support referral links to allow users and partners to earn rewards for bringing in new users. When a user visits via a referral link, any subsequent deposit transactions they make should be directed to a specific on-chain referral vault address associated with the referrer, instead of the default foundation contract.

The user journey should be seamless. The referral mechanism should work for general site visits and for direct links to specific "spell" pages.

Supported URL structures:
- `https://noema.art/ref/:referralCode`
- `https://noema.art/:spell/ref/:referralCode`
- `https://noema.art/?ref=:referralCode` (and on any other page)

The core requirement is to dynamically change the recipient address in the transaction data generated by the `pointsApi` based on the presence of a valid referral code.

## Decision
We will implement a server-side, cookie-based mechanism to track referrals and route transactions. This approach centralizes the logic on the backend and requires minimal changes to the frontend application.

The implementation will consist of three main parts:

### 1. Referral Code Detection Middleware
A new Express middleware will be added to `src/platforms/web/index.js`.
- This middleware will inspect the URL of every incoming request for a referral code, matching patterns like `/ref/:code`, `/:spell/ref/:code`, or a query parameter `?ref=...`.
- If a referral code is found, it will be stored in a secure, `httpOnly` cookie named `referral_code`. This cookie will persist for 90 days. `httpOnly` prevents access from client-side JavaScript, enhancing security.
- For path-based referral links (e.g., `/ref/remilio`), the middleware will redirect the user to the site's root (`/`) to provide a clean URL in the browser's address bar, while the cookie ensures the referral is tracked.
- If the user is not logged in, the referral code will also be stored in localStorage for opportunistic migration.

### 2. User Preference Storage and Migration
- When a user logs in or creates an account, if a referral code exists in localStorage/cookie and not in their preferences, it will be migrated to their user profile and cleared from localStorage/cookie.
- The user's default referral vault will be stored in their preferences under the key `preferredCharteredFund` (not in userCore).
- This preference can be updated or removed by the user via the settings UI (to be implemented).
- If a user visits with a new referral link, it will overwrite the previous preference.

### 3. API Layer Integration
- The external-facing `/api/external/points/purchase` endpoint in `src/api/external/pointsApi.js` will be updated to read the referral code from the user's preferences (if logged in) or from the cookie/localStorage (if not).
- This code will be passed along in the body of the request to the internal `/internal/v1/data/points/purchase` endpoint.

### 4. Dynamic Transaction Recipient Logic
- The internal purchase logic in `src/api/internal/pointsApi.js` will be modified to check for a `referralCode` (from preferences or cookie/localStorage).
- If a code is present, it will query the database to find the on-chain address of the corresponding referral vault.
- If a valid vault address is found, it will be used as the recipient (`to`) address for the blockchain transaction.
- If the referral code is invalid, not found, or not provided, the system will gracefully fall back to using the default foundation contract address. This ensures the system remains robust and that normal transactions are not affected.

### 5. Anonymous Transactions
- Anonymous (not logged in) users are allowed to transact using a referral vault.
- This supports the use case where a user visits a spell page and pays for a workflow up front, without creating an account. (A profile may be created for them in the background.)

### 6. Settings UI
- The settings modal (to be built) will allow users to view, change, or remove their default referral vault (`preferredCharteredFund`).
- For now, this can be managed via API endpoints and surfaced in the UI later.

### 7. Analytics
- The system will log when a referral code is set (either in preferences or localStorage/cookie).
- Referral rewards will continue to be tracked on-chain and off-chain as currently implemented.

## Consequences

### Pros
- **Secure**: Using an `httpOnly` cookie and user preferences protects the referral code from being tampered with on the client-side.
- **Seamless UX**: Users are redirected to a clean URL and the referral tracking happens transparently.
- **Low Frontend Impact**: The frontend application does not need to be aware of the referral logic, minimizing changes to client-side code.
- **Robust**: The system defaults to standard behavior if a referral code is invalid, preventing errors.
- **Centralized Logic**: The core logic is contained within the backend, making it easier to manage and update.
- **Anonymous Support**: Users can transact without an account, supporting one-off spell/workflow purchases.

### Cons
- **New Middleware**: Adds a small piece of logic that runs on every request.
- **DB Lookup**: Introduces a database lookup in the critical path of a purchase, which must be performant.
- **Settings UI Needed**: Requires a settings UI for users to manage their referral vault preference.

## Alternatives Considered

### 1. Client-Side Handling (e.g., `localStorage`)
- **Description**: The frontend JavaScript could parse the referral code from the URL, store it in `localStorage`, and then manually add it to the body of the `/purchase` API call.
- **Reason for Rejection**: This approach is less secure as `localStorage` is accessible to any script on the page. It also requires more significant changes to the frontend codebase and places the responsibility of managing the referral token on the client.

### 2. Server-Side Session
- **Description**: Store the referral code in a server-side session (e.g., using `express-session`).
- **Reason for Rejection**: While viable, this would introduce statefulness and require a session management layer, which may be more complexity than is needed. The cookie-based approach is lighter and fits well with a potentially stateless API design. 

---

## Codebase Integration Guide & Citations

To ensure a robust and maintainable implementation, here are targeted codebase references and examples for each part of the plan:

### 1. User Preferences Storage and Access
- **File:** `src/core/services/db/userPreferencesDb.js`
- **Key Methods:**
  - `setPreferenceByKey(masterAccountId, 'preferredCharteredFund', { vaultName, vaultAddress })` to store the referral vault.
  - `getPreferenceByKey(masterAccountId, 'preferredCharteredFund')` to fetch the preference.
- **API Exposure:**
  - `src/api/internal/userPreferencesApi.js` exposes GET/PUT `/users/:masterAccountId/preferences` and scoped endpoints for preferences.

### 2. Transaction Recipient Logic in pointsApi.js
- **File:** `src/api/internal/pointsApi.js`
- **Integration Point:**
  - In the `/purchase` route, the recipient address is determined. Update logic to accept a `recipientAddress` (from user preferences or referral code) and use it if present and valid, otherwise default to the foundation contract address.
  - Example:
    ```js
    // In /purchase route
    let toAddress = foundationAddress;
    if (recipientAddress && isValidAddress(recipientAddress)) {
      toAddress = recipientAddress;
    }
    ```

### 3. User Login/Session Creation and Migration
- **Files:**
  - `src/platforms/web/middleware/auth.js` (JWT/session logic)
  - `src/api/internal/userCoreApi.js` (user profile creation, preferences mounting)
- **Integration Point:**
  - After successful login, check for a referral code in localStorage/cookie (frontend) or request (backend). If present and not in user preferences, migrate it using the preferences API.

### 4. Frontend: Buy Points Modal and Referral Logic
- **File:** `src/platforms/web/client/src/sandbox/components/BuyPointsModal/buyPointsModal.js`
- **Integration Point:**
  - Before sending a purchase request, check for a referral vault address:
    - If logged in, fetch from `/api/v1/user/dashboard` or `/me` (should include `preferredCharteredFund`).
    - If not logged in, check localStorage/cookie.
    - Add the referral vault address to the purchase request body if present.
  - Example:
    ```js
    const body = {
      // ...existing fields...
      recipientAddress: referralVaultAddress // if available
    };
    ```

### 5. Settings UI and Account Dropdown
- **File:** `src/platforms/web/client/src/sandbox/components/accountDropdown.js`
- **Integration Point:**
  - Fetch and display the user's `preferredCharteredFund` in the account dropdown and (future) settings modal.
  - Allow updating/removing the preference via the preferences API.

### 6. Anonymous Transactions
- **Frontend:**
  - If not logged in, store the referral code in localStorage/cookie and use it for purchases.
- **Backend:**
  - Accept the referral code from the request body for anonymous purchases and use it to look up the vault address.

---

**These citations and examples should be referenced during implementation to ensure alignment with the architecture and to facilitate onboarding for future contributors.** 

---

## Implementation Notes & Status

**Status: Completed (as of 2025-07-18)**

The core functionality described in this ADR has been fully implemented and verified. The system now correctly handles referral link detection, cookie-based tracking, transaction routing to referral vaults, and migration of referral codes to user preferences upon login.

### Key Implementation Details & Corrections:

1.  **Referral Vault Database:**
    *   **Correction:** The initial plan mentioned a separate `referralVaultsDb`. The implementation was corrected to use the existing `creditLedgerDb` (`credit_ledger` collection), which already stores referral vault information. The method `creditLedgerDb.findReferralVaultByName` is used for lookups.

2.  **Referral Payout Logic (`creditService.js`):**
    *   **Correction:** The initial implementation had a flawed "protocol markup" concept. This was corrected to align with the intended business logic.
    *   **Current Logic:** Referral rewards (5% of the gross deposit USD value) are paid out from the platform's share, which is derived from the `fundingRate` applied to the deposit. This logic is now active and credits the referrer's account accordingly.

3.  **Authentication Flow (`authApi.js`):**
    *   The `/web3/verify` external endpoint now correctly reads the `referral_code` from the cookie and passes it to the internal `/find-or-create-by-wallet` endpoint.
    *   The `/find-or-create-by-wallet` endpoint successfully checks for the `referralCode` and saves it to the user's `preferredCharteredFund` preference if one is not already set.

4.  **Transaction Construction (`pointsApi.js`):**
    *   The internal `/purchase` endpoint now correctly looks up the referral vault's address and uses it as the `to` address for the on-chain transaction.
    *   A bug was fixed where the `from` address was missing in the transaction data returned to the client, which caused MetaMask errors. The `from: userWalletAddress` field is now correctly included.
    *   **Enhancement:** The external `/purchase` endpoint was updated to be fully persistent. It first checks for a referral code in the request cookie. If none is found, it falls back to checking and using the logged-in user's saved `preferredCharteredFund` preference, ensuring the referral is honored across sessions.

The implementation is robust, with graceful fallbacks to the default foundation contract if a referral code is invalid or the corresponding vault is not found. 