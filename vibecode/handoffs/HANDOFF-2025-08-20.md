# HANDOFF: 2025-08-20 – Re-authentication Modal for Sandbox

## Work Completed
- Implemented `ReauthModal.js` in `src/platforms/web/client/src/sandbox/components/`
  - Provides full login experience (wallet signature, username/password, API-key) identical to landing page.
  - Dynamically loads `ethers.js` when needed, preventing missing wallet library errors.
  - Emits `reauth-success` event and refreshes cached CSRF token on success.
- Added global fetch interceptor in `sandbox/index.js` to automatically open the modal on any HTTP `401` response so users never lose their workspace.
- Ensured idempotent initialization & single-instance modal behavior.
- Followed existing modal styling conventions (`.modal-overlay`, `.panel`, etc.) so it blends with current UI.

## Current State
The sandbox now seamlessly prompts users to re-authenticate when their JWT expires or when an authorized action is attempted:
1. Any sandbox network call that returns `401` triggers `window.openReauthModal()`.
2. Modal offers three auth paths mirroring landing page(Login via Wallet, Username/Password, API Key).
3. On success, modal closes, CSRF cache resets, and a `reauth-success` event allows the app to refresh state if needed.
4. Workspace remains completely intact throughout the flow.

## Next Tasks
- Hook listeners to `reauth-success` to refresh user-dependent data (collections, cook status, etc.) automatically.
- Centralize modal CSS rules into a shared stylesheet if we want to avoid inline styles.
- Add Playwright test covering JWT expiry → 401 → reauth → resumed action.
- Consider exposing `openReauthModal()` as part of a wider auth utility.

## Changes to Plan
No larger architectural changes; new component fits within existing sandbox frontend layer and respects boundary rules.

## Open Questions
- Should we persist unsaved canvas changes across full page reload just in case reauth fails and user chooses to reload?
- Any additional auth methods (OAuth) we should support inside the modal?

---

# HANDOFF: 2025-08-20 – Tool Window Versioning & History UI

## Work Completed
- **Replaced duplicate-window execution workflow with inline versioning**
  - Removed duplicate window creation on Execute; the same node now records successive outputs as versions.
- **Version history data model**
  - Each `toolWindow` now maintains `outputVersions` (array) and `currentVersionIndex`.
  - Snapshots of `parameterMappings` are stored per version so we can fully restore a run.
- **UI additions**
  - Added left-aligned version selector button (`vN`, `vN*` when pending).
  - Dropdown lists all versions; click to restore parameters and output.
  - Styling tweaks: min-width, black text, box-shadow for readability.
- **Parameter change tracking**
  - Editing any static input instantly opens/updates a *pending* version placeholder.
  - On run completion, placeholder swaps to the final output.
- **State integration**
  - `setToolWindowOutput` now updates/creates version entries and refreshes the UI in-place.
- **Refactors & cleanup**
  - Central helper `applyParameterMappings` to rehydrate inputs when switching versions.
  - Removed obsolete duplicate-connection logic.

## Current State
Users can iterate on the same node:
1. Change parameters – a new version placeholder appears.
2. Click Execute – run completes, output attaches to that version.
3. Select any `vN` from dropdown – inputs & output revert exactly to that run.
This greatly reduces canvas clutter and clarifies history.

## Next Tasks
- Persist `outputVersions` array in localStorage so history survives page refresh.
- Optionally allow renaming versions for easier recall.
- Add Playwright/regression tests for version selector workflow.
- Evaluate memory footprint for very large version histories and add trimming if needed.

## Changes to Plan
No architectural deviations; changes stay within sandbox client layer and respect boundary rules.

## Open Questions
- Should version history include execution timestamp and runtime stats?
- Persist images to IndexedDB for offline viewing?

---

# HANDOFF: 2025-08-20 – Tool Window Fixed-Width & Full-Screen Toggle

## Work Completed
- Converted `.tool-window` to use a fixed width (`--tool-window-fixed-width: 340px`) so every node has a consistent footprint.
- Added full-screen / normal toggle button (⤢ / ↙) in window header:
  - Stores and restores original position & size.
  - Applies `.fullscreen` class (position: fixed; 100 vw×100 vh; overflow: visible).
- Ensured anchors remain outside the frame by forcing `overflow: visible` on both normal and fullscreen states.
- Auto-expands *Optional Parameters* panel when entering fullscreen, restoring previous state on exit.
- No linter errors; CSS & JS modifications confined to `sandbox` client layer.

## Current State
The node canvas now offers two viewing modes per window:
1. **Default (fixed-width)** – compact, grid-snapped nodes ideal for graph layout.
2. **Full-screen** – maximized node for comfortable parameter editing & output review; optional params visible by default.
Anchors (input/output) remain correctly positioned outside either layout.

## Next Tasks
- Persist fullscreen state per window in localStorage so refreshes keep your chosen mode.
- Add keyboard shortcut (e.g. `F` while a node is focused) to toggle fullscreen faster.
- Consider dynamic width breakpoints instead of a single fixed value if users want a slightly wider compact view.
- Playwright test: verify optional panel auto-expands on fullscreen enter.

## Changes to Plan
Feature stays within sandbox front-end scope. No cross-layer impacts.

## Open Questions
- Should fullscreen windows temporarily hide anchors and connections for distraction-free editing?
- Do we want a “fluid width” preference instead of fixed 340 px for compact view?
