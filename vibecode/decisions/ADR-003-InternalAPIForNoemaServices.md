# ADR-003: Centralizing Noema DB Access via Internal API\n\n## Status\nProposed\n\n## Context\n\nFollowing the implementation of the foundational Noema database services (`userCore`, `userSessions`, `userEvents`, etc.) and a pilot integration into the Telegram `/status` command (`HANDOFF-2025-05-08-NoemaPilotIntegrationReflections.md`), several challenges and opportunities related to multiplatform architecture have emerged.\n\n1.  **Consistency Risk:** Directly accessing `services.db.noema.*` from each platform adapter (Telegram, Discord, Web) and potentially core workflows risks scattering DB interaction logic, leading to duplication and potential inconsistencies in how data is retrieved, validated, and updated across different user touchpoints.\n2.  **Security & Validation:** Business rules, authorization checks (e.g., ensuring sufficient funds before debiting), and critical sequences (e.g., updating economy + logging transaction) need to be enforced reliably. Implementing these consistently across multiple platform entry points is error-prone.\n3.  **Maintainability:** Changes to Noema DB schemas or core data access logic would require updates in numerous places if access is decentralized.\n4.  **RESTful Principles:** Adhering to REST principles (Client-Server separation, Statelessness, Uniform Interface) for internal communication can improve architectural clarity and robustness, even for an internally-facing API.\n\nThe pilot integration, while successful, involved significant debugging related to dependency injection and required direct calls to DB services from the Telegram command handler. This highlighted the need for a more robust pattern before integrating into complex, cost-incurring features.\n\n## Decision (Proposed for Discussion)\n\n**All application components (Platform Adapters, potentially Core Workflows) MUST interact with the Noema database collections (`userCore`, `userSessions`, etc.) exclusively through a dedicated Internal API layer (`src/api/internal/`).**\n\n*   Direct access to `services.db.noema.*` objects from `src/platforms/` or `src/core/workflows/` will be prohibited.\n*   The Internal API will expose RESTful endpoints representing the Noema data resources and operations.\n*   This API layer becomes the sole gatekeeper responsible for: \n    *   Interacting with the `services.db.noema.*` classes.\n    *   Enforcing data validation and business logic (e.g., balance checks).\n    *   Handling atomic sequences (e.g., economy updates + transaction logging).\n    *   Managing user/session context retrieval based on identifiers passed from the platforms.\n\n## Consequences\n\n### Positive:\n*   **Centralized Logic:** DB interaction logic, validation, and business rules are located in one place, improving consistency and maintainability.\n*   **Improved Security Boundary:** Platforms don\'t need direct DB credentials or access; they interact via a controlled API interface.\n*   **Enhanced Testability:** The Internal API layer can be tested independently.\n*   **Clearer Architecture:** Enforces separation of concerns between platform adaptation and core data services.\n*   **Consistency Across Platforms:** Ensures features behave identically regardless of the originating platform (Telegram, Discord, Web).\n\n### Negative/Challenges:\n*   **Increased Complexity:** Introduces an additional API layer that needs definition, implementation, and maintenance.\n*   **Performance Overhead:** Replacing direct service calls with local HTTP requests introduces some latency (though likely minimal for localhost calls).\n*   **API Contract Definition:** Requires careful design and documentation of the Internal API endpoints, request/response formats, and error handling.\n\n## Key Questions for Architectural Discussion\n\n1.  **API Endpoint Design:** What specific RESTful endpoints (URIs, HTTP methods, request/response bodies) are required to map the functionality of the seven Noema DB services?\ (e.g., `POST /internal/sessions`, `GET /internal/users/by-platform/{platform}/{id}`, `POST /internal/transactions`, etc.)\n2.  **Context Propagation:** How will user context (`masterAccountId`, potentially `sessionId`) be securely and reliably passed from the originating platform request (e.g., Telegram message) to the relevant Internal API calls? (e.g., Opaque tokens generated after initial lookup? Passing platform IDs for lookup within each API call?)\n3.  **Authentication/Authorization:** How will the Internal API differentiate and authorize requests originating from different internal sources (Telegram bot vs Discord bot vs Web backend)? Is trusting localhost sufficient, or is a simple internal API key/token needed?\n4.  **Atomicity Implementation:** How will sequences requiring atomicity (e.g., `UserEconomyDB.updateUsdCredit` + `TransactionsDB.logTransaction`) be implemented within a single Internal API endpoint to ensure data integrity?\n5.  **Error Handling:** Define standard error responses and status codes for the Internal API.\n6.  **Workflow Interaction:** Should core workflows (`src/core/workflows/`) also use the Internal API, or can they retain direct access to `services` (excluding `services.db.noema`)? Using the API enforces the boundary but adds overhead.\n7.  **Performance Impact:** Evaluate the potential performance impact of introducing internal HTTP calls for frequent operations.\n8.  **Existing Internal API:** How does this integrate with the current structure in `src/api/internal/` (e.g., `status.js`)? Does the current `initializeAPI` pattern support this?\n\n## Alternatives Considered\n\n1.  **Direct DB Service Access (Current Pilot state):** Continue allowing platforms to call `services.db.noema.*` directly. Rejected due to risks of inconsistency, scattered logic, and difficulty enforcing rules across platforms.\n2.  **Shared Core Logic Layer (Non-API):** Create shared functions within `src/core/` (e.g., `getUserContext(platform, id)`, `performDebit(masterAccountId, amount)`) that encapsulate DB calls, and have platforms call these functions. This reduces duplication but doesn\'t provide the same clear network boundary or strict enforcement as an API layer, and dependency injection can still be complex.\n 