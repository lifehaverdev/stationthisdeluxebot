/**
 * @file Manages database operations for the userCore collection in the Noema database.
 */

const { BaseDB, ObjectId } = require('./BaseDB');
const { PRIORITY } = require('./utils/queue');

const COLLECTION_NAME = 'userCore';

class UserCoreDB extends BaseDB {
  constructor() {
    super(COLLECTION_NAME);
  }

  /**
   * Finds a userCore document by its masterAccountId.
   * @param {ObjectId | string} masterAccountId - The masterAccountId of the user.
   * @returns {Promise<Object|null>} The userCore document or null if not found.
   */
  async findUserCoreById(masterAccountId) {
    const id = typeof masterAccountId === 'string' ? new ObjectId(masterAccountId) : masterAccountId;
    return this.findOne({ _id: id }, PRIORITY.HIGH);
  }

  /**
   * Finds a userCore document by a platform identifier.
   * @param {string} platformName - E.g., 'telegram', 'discord'.
   * @param {string} platformId - The user's ID on that platform.
   * @returns {Promise<Object|null>} The userCore document or null if not found.
   */
  async findUserCoreByPlatformId(platformName, platformId) {
    const query = { [`platformIdentities.${platformName}`]: platformId };
    return this.findOne(query, PRIORITY.HIGH);
  }

  /**
   * Finds a userCore document by platform identifier, or creates one if not found.
   * @param {string} platformName - E.g., 'telegram', 'discord'.
   * @param {string} platformId - The user's ID on that platform.
   * @param {Object} [additionalData={}] - Additional data to include if creating a new user.
   * @returns {Promise<Object|null>} The userCore document.
   */
  async findOrCreateByPlatformId(platformName, platformId, additionalData = {}) {
    let user = await this.findUserCoreByPlatformId(platformName, platformId);
    if (user) {
      return user;
    }

    // User not found, create a new one
    const timestamp = new Date();
    const newUserDocumentData = {
      platformIdentities: {
        [platformName]: platformId,
      },
      wallets: [],
      apiKeys: [],
      awards: [],
      profile: {},
      status: 'active',
      userCreationTimestamp: timestamp,
      updatedAt: timestamp,
      lastLoginTimestamp: timestamp, // Set lastLogin on creation as well
      lastSeenPlatform: platformName, // Set lastSeenPlatform on creation
      ...additionalData, // Allow overriding defaults or adding more info
    };

    // Ensure platformIdentities from additionalData are merged, not overwritten, if any.
    if (additionalData.platformIdentities) {
      newUserDocumentData.platformIdentities = {
        ...newUserDocumentData.platformIdentities,
        ...additionalData.platformIdentities,
      };
    }

    try {
      user = await this.createUserCore(newUserDocumentData);
      // createUserCore in the current implementation returns { _id: result.insertedId, ...newUserDocument }
      // which is what we want.
      if (!user || !user._id) { // Defensive check
        // Log error or throw, as createUserCore should ideally always return a user or throw
        console.error(`[UserCoreDB] Failed to create user for ${platformName}:${platformId} but createUserCore did not throw or return valid user.`);
        return null;
      }
      return user;
    } catch (error) {
      console.error(`[UserCoreDB] Error creating user for ${platformName}:${platformId}:`, error);
      // Depending on desired error handling, re-throw or return null
      throw error; // Or return null if preferred that callers handle it
    }
  }

  /**
   * Finds a userCore document by a wallet address.
   * @param {string} walletAddress - The wallet address.
   * @returns {Promise<Object|null>} The userCore document or null if not found.
   */
  async findUserCoreByWalletAddress(walletAddress) {
    // Ensure case-insensitivity if wallet addresses might be stored with varying cases
    // Or ensure they are always stored checksummed/lowercase.
    // For now, assuming direct match.
    return this.findOne({ 'wallets.address': walletAddress }, PRIORITY.HIGH);
  }

  /**
   * Creates a new userCore document.
   * @param {Object} userData - The initial data for the new user.
   * @returns {Promise<Object>} The created userCore document including its _id.
   */
  async createUserCore(userData) {
    const timestamp = new Date();
    const newUserDocument = {
      platformIdentities: {}, // Should be provided or explicitly set
      wallets: [],
      apiKeys: [],
      awards: [],
      profile: {},
      status: 'active',
      ...userData, // userData can override defaults
      userCreationTimestamp: userData.userCreationTimestamp || timestamp,
      updatedAt: timestamp,
    };
    // _id will be auto-generated by MongoDB and included in the result of insertOne
    const result = await this.insertOne(newUserDocument, false, PRIORITY.CRITICAL);
    return { _id: result.insertedId, ...newUserDocument }; // Return the document with the new _id
  }

  /**
   * Updates an existing userCore document.
   * Automatically sets the updatedAt timestamp.
   * @param {ObjectId | string} masterAccountId - The masterAccountId of the user to update.
   * @param {Object} updateOperations - MongoDB update operators (e.g., { $set: { field: value } }).
   * @returns {Promise<Object|null>} The updated userCore document or null if not found.
   */
  async updateUserCore(masterAccountId, updateOperations) {
    const id = typeof masterAccountId === 'string' ? new ObjectId(masterAccountId) : masterAccountId;
    const updateDoc = {
      ...updateOperations,
      $set: {
        ...(updateOperations.$set || {}),
        updatedAt: new Date(),
      },
    };
    // BaseDB.updateOne returns the result of the operation, not the document.
    // To get the updated document, we'd typically findOneAndUpdate or findOne after update.
    // Modifying BaseDB.updateOne to return document or doing a subsequent find is an option.
    // For now, let's assume we need to fetch it if BaseDB.updateOne doesn't return it.
    const updateResult = await super.updateOne({ _id: id }, updateDoc, {}, false, PRIORITY.HIGH);
    if (updateResult.matchedCount > 0 || updateResult.upsertedId) {
        return this.findUserCoreById(id); // Fetch the updated document
    }
    return null;
  }

  /**
   * Adds an award to a user's profile.
   * @param {ObjectId | string} masterAccountId
   * @param {Object} awardData - Object containing awardId, achievedAt, displayName, description.
   * @returns {Promise<Object|null>} The updated userCore document.
   */
  async addAward(masterAccountId, awardData) {
    const award = {
        achievedAt: new Date(),
        ...awardData
    }
    return this.updateUserCore(masterAccountId, { $push: { awards: award } });
  }

  /**
   * Updates specific fields in the user's profile object.
   * @param {ObjectId | string} masterAccountId
   * @param {Object} profileUpdates - Object with fields to update (e.g., { displayName: 'New Name' }).
   * @returns {Promise<Object|null>} The updated userCore document.
   */
  async updateProfile(masterAccountId, profileUpdates) {
    const $set = {};
    for (const key in profileUpdates) {
      if (profileUpdates.hasOwnProperty(key)) {
        $set[`profile.${key}`] = profileUpdates[key];
      }
    }
    if (Object.keys($set).length === 0) {
        return this.findUserCoreById(masterAccountId); // No changes, return current doc
    }
    return this.updateUserCore(masterAccountId, { $set });
  }

  /**
   * Updates the last login timestamp and platform for a user.
   * @param {ObjectId | string} masterAccountId
   * @param {string} platform - The platform the user logged in from.
   * @returns {Promise<Object|null>} The updated userCore document.
   */
  async updateLastLogin(masterAccountId, platform) {
    return this.updateUserCore(masterAccountId, {
      $set: {
        lastLoginTimestamp: new Date(),
        lastSeenPlatform: platform,
      },
    });
  }
  
  /**
   * Adds a platform identity to the user.
   * @param {ObjectId | string} masterAccountId
   * @param {string} platformName e.g., 'telegram', 'discord'
   * @param {string} platformId The user's ID on that platform.
   * @returns {Promise<Object|null>} Updated userCore document.
   */
  async addPlatformIdentity(masterAccountId, platformName, platformId) {
    const updateDoc = { $set: { [`platformIdentities.${platformName}`]: platformId } };
    return this.updateUserCore(masterAccountId, updateDoc);
  }

  /**
   * Adds a wallet to the user's wallets array.
   * @param {ObjectId | string} masterAccountId
   * @param {Object} walletData - { address: string, isPrimary?: boolean, verified?: boolean }
   * @returns {Promise<Object|null>} Updated userCore document.
   */
  async addWallet(masterAccountId, walletData) {
    const newWallet = {
        addedAt: new Date(),
        verified: false, // Default to not verified
        isPrimary: false, // Default to not primary
        ...walletData,
    };
    // Potentially add logic here to ensure only one primary wallet if isPrimary is true.
    // This might involve multiple operations or more complex update logic.
    return this.updateUserCore(masterAccountId, { $push: { wallets: newWallet } });
  }

  /**
   * Updates a user's status.
   * @param {ObjectId | string} masterAccountId
   * @param {string} status - New status (e.g., 'active', 'suspended').
   * @returns {Promise<Object|null>} Updated userCore document.
   */
  async updateUserStatus(masterAccountId, status) {
    // Add validation for allowed status values if needed, based on schema enum
    return this.updateUserCore(masterAccountId, { $set: { status: status } });
  }

}

module.exports = new UserCoreDB(); 